package spike.core;

import System from spike.core.System;
import Utils from spike.core.Util;

static class Events {

  /**
   * List of allowed events which can be binded by Spike Framework and compiled by Spike compiler
   */
  allowedEvents: [
    'click',
    'change',
    'keyup',
    'keydown',
    'keypress',
    'blur',
    'focus',
    'dblclick',
    'die',
    'hover',
    'keydown',
    'mousemove',
    'mouseover',
    'mouseenter',
    'mousedown',
    'mouseleave',
    'mouseout',
    'submit',
    'toggle',
    'load',
    'unload'
  ],

  __eventsReferences: {},
  __linkReferences: {},

  bindEvents: function(element){

    this.bindEventsForElement(element);
    for(var i = 0; i < element.childElements.length; i++){

        if(element.childElements[i].length > 0){
            this.bindEvents(element.childElements[i]);
        }

    }

  },

  /**
   * @public
   *
   * Finds all elements with attribute @spike-event
   * in given (root) selector.
   *
   * Gets event name and event function string, binds
   * jQuery event with created function.
   *
   * @param rootSelector
   */
  bindEventsForElement: function (element) {

    for(var i = 0; i < element.eventsSelectors.length; i++){

        if(typeof element.eventsSelectors[i] === 'string'){
            element.eventsSelectors[i] = document.getElementById(element.eventsSelectors[i]);
        }

        if(element.eventsSelectors[i].getAttribute('spike-unbinded') != null){

            for (var k = 0; k < this.allowedEvents.length; k++) {

                var eventFunctionBody = element.eventsSelectors[i].getAttribute('spike-event-' + this.allowedEvents[k]);

                if (eventFunctionBody) {

                    var eventRef = element.eventsSelectors[i].id+'_'+this.allowedEvents[k];

                    if(!this.__eventsReferences[eventRef]){

                        var eventFnLinkHash = element.eventsSelectors[i].getAttribute('spike-event-' + this.allowedEvents[k]+'-link');
                        eventFnLink = $this.__linkReferences[eventFnLinkHash];
                       // eventFnLink = eventFnLink.apply.bind(eventFnLink, element.eventsSelectors[i], $this.__linkReferences[eventFnLinkHash].args);

                        this.__eventsReferences[eventRef] = eventFnLink;
                        element.eventsSelectors[i].addEventListener(this.allowedEvents[k], this.__eventsReferences[eventRef]);
                    }

                }

            }

        }

        element.eventsSelectors[i].removeAttribute('spike-unbinded');

    }

  },


  removeEventListeners: function(element){

    for(var i = 0; i < element.eventsSelectors.length; i++){

        if(typeof element.eventsSelectors[i] === 'string'){
            element.eventsSelectors[i] = document.getElementById(element.eventsSelectors[i]);
        }

        for (var k = 0; k < this.allowedEvents.length; k++) {

            var eventRef = element.eventsSelectors[i].id+'_'+this.allowedEvents[k];

            if(this.__eventsReferences[eventRef]){
                element.eventsSelectors[i].removeEventListener(this.allowedEvents[k], this.__eventsReferences[eventRef]);
            }

        }

    }

  },

  linkEvent: function(fn){

    var linkId = Utils.hash();
    $this.__linkReferences[linkId] = fn;

    return linkId;

  },

}